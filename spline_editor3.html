<!doctype html>
<html lang="en">

<head>
	<title>three.js webgl - draggable 3d catmull spline editor</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		font-family: monospace;
		background-color: #f0f0f0;
		margin: 0px;
		overflow: hidden
	}

	</style>
</head>

<body>
	<script src="js/three.min.js"></script>
	<script src="js/stats.min.js"></script>
	<script src="js/Projector.js"></script>
	<script src="DragControls3.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/TransformControls.js"></script>

	<script>
	String.prototype.format = function () {
		var str = this;
		for (var i = 0; i < arguments.length; i++) {
			str = str.replace('{' + i + '}', arguments[i]);
		}
		return str;
	}

	var container, stats;
	var camera, scene, renderer;
	var splineHelperObjects = [],
		splineOutline;
	var splineCurve, splinePointsLength = 4;
	var positions = [];
	var options;
	
	var geometry = new THREE.BoxGeometry(20, 20, 20);
	var splineMesh;

	init();
	animate();

	function init() {
		container = document.createElement('div');
		document.body.appendChild(container);
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
		camera.position.z = 1000;
		scene.add(camera);


		scene.add(new THREE.AmbientLight(0xf0f0f0));
		var light = new THREE.SpotLight(0xffffff, 1.5);
		light.position.set(0, 1500, 200);
		light.castShadow = true;
		light.shadowCameraNear = 200;
		light.shadowCameraFar = camera.far;
		light.shadowCameraFov = 70;
		light.shadowBias = -0.000222;
		light.shadowDarkness = 0.25;
		light.shadowMapWidth = 1024;
		light.shadowMapHeight = 1024;
		scene.add(light);
		spotlight = light;
		var planeGeometry = new THREE.PlaneGeometry(2000, 2000, 20, 20);
		planeGeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
		var planeMaterials = [new THREE.MeshBasicMaterial({
			color: 0xeeeeee,
			opacity: 0.5
		}), new THREE.MeshBasicMaterial({
			color: 0x405040,
			wireframe: true,
			opacity: 0.2,
			transparent: true
		})];
		var plane = THREE.SceneUtils.createMultiMaterialObject(planeGeometry, planeMaterials);
		// plane.position.y = -500;
		plane.children[0].castShadow = false;
		plane.children[0].receiveShadow = true;
		scene.add(plane);
		var axis = new THREE.AxisHelper();
		axis.position.set(-500, -500, -500);
		scene.add(axis);
		var i;
		for (i = 0; i < splinePointsLength; i++) {
			addSplineObject(positions[i]);
		}
		positions = [];
		for (i = 0; i < splinePointsLength; i++) {
			positions.push(splineHelperObjects[i].position);
		}
		splineCurve = new THREE.SplineCurve3(positions);

		renderer = new THREE.WebGLRenderer({
			antialias: true
		});
		renderer.setClearColor( 0xf0f0f0 );
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		container.appendChild(renderer.domElement);
		var info = document.createElement('div');
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
		info.innerHTML = '<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> - simple 3d catmull-rom <a href="http://twitter.com/blurspline" target="_blank">@blurspline</a> spline editor';
		options = document.createElement('div');
		options.style.position = 'absolute';
		options.style.top = '30px';
		options.style.width = '100%';
		options.style.textAlign = 'center';
		options.innerHTML = 'Points: <input type="button" onclick="addPoint();" value="+" /><input type="button" onclick="removePoint();" value="-" /><br /><input type="button" onclick="exportSpline();" value="Export" />';
		container.appendChild(info);
		container.appendChild(options);
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild(stats.domElement);

		// Controls
		controls = new THREE.OrbitControls( camera );
		controls.damping = 0.2;
		controls.addEventListener( 'change', render );

		transformControl = new THREE.TransformControls( camera, renderer.domElement );
		transformControl.addEventListener( 'change', render );
		// transformControl.setMode( "translate" );
		// transformControl.setSize( 100 );

		scene.add( transformControl );

		transformControl.addEventListener('change', function(e) {
			console.log('change', e.target);
		});

		transformControl.addEventListener('mouseDown', function(e) {
			controls.enabled = false;
			cancelHideTransorm();
			// console.log('mouseDown', e);
		});

		transformControl.addEventListener('mouseUp', function(e) {
			controls.enabled = true;
			// console.log('mouseUp', e, controls);
			hideTransform();
		});

		transformControl.addEventListener('objectChange', function(e) {
			updateSplineOutline();
			// e.stopPropagation();

		});

		var dragcontrols = new THREE.DragControls(camera, splineHelperObjects, renderer.domElement); // 

		dragcontrols.on('hoveron', function(e) {
			transformControl.attach(e.object);
			cancelHideTransorm();
		})

		dragcontrols.on('hoveroff', function(e) {
			if (e) hideTransform();
		})

		var hiding;
		function hideTransform() {
			cancelHideTransorm();
			hiding = setTimeout(function() {
				transformControl.detach(transformControl.object);
			}, 1500);
		}

		function cancelHideTransorm() {
			if (hiding) clearTimeout(hiding);
		}

		// dragcontrols.on('dragstart', function(e) {
		// 	controls.enabled = false;
		// });

		// dragcontrols.on('dragend', function() {
		// 	controls.enabled = true;
		// 	updateSplineOutline();
		// });


		splineMesh = new THREE.Line(new THREE.Geometry(), new THREE.LineBasicMaterial({
			color: 0x000000,
			opacity: 0.35,
			width: 2
		}));

		for (var i = 0; i < 200; i++) {
			splineMesh.geometry.vertices.push(new THREE.Vector3());
		}

		scene.add(splineMesh);
		updateSplineOutline();

	}

	function addSplineObject(position) {
		var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
			color: Math.random() * 0xffffff
		}));
		object.material.ambient = object.material.color;
		if (position) {
			object.position.copy(position);
		} else {
			object.position.x = Math.random() * 1000 - 500;
			object.position.y = Math.random() * 600
			object.position.z = Math.random() * 800 - 400;
		}
		object.castShadow = true;
		object.receiveShadow = true;
		scene.add(object);
		splineHelperObjects.push(object);
		return object;
	}

	function addPoint() {
		splinePointsLength ++;
		positions.push(addSplineObject()
					.position);

		updateSplineOutline();
	}

	function removePoint() {
		if (splinePointsLength <= 4) {
			return;
		}
		splinePointsLength --;
		positions.pop();
		scene.remove(splineHelperObjects.pop());
		
		updateSplineOutline();
	}

	function updateSplineOutline() {
		// if (splineOutline) scene.remove(splineOutline);
		// splineCurve.updateArcLengths();
		// var arcLen = splineCurve.getLength();
		// arcLen = Math.floor(arcLen / 20);
		// var spacedPoints = createLineGeometry(splineCurve.getPoints(arcLen));
		// splineOutline = new THREE.Line(spacedPoints, new THREE.LineBasicMaterial({
		// 	color: 0x000000,
		// 	opacity: 0.35
		// }));
		// scene.add(splineOutline);

		var p;
		for (var i = 0; i < 200; i++) {
			p = splineMesh.geometry.vertices[i];

			p.copy(splineCurve.getPoint(i /  (200 - 1)));
		}

		splineMesh.geometry.verticesNeedUpdate = true;
	}

	function exportSpline() {
		var p;
		var strplace = [];
		for (i = 0; i < splinePointsLength; i++) {
			p = splineHelperObjects[i].position;
			strplace.push('new THREE.Vector3({0}, {1}, {2})'.format(p.x, p.y, p.z))
		}
		console.log(strplace.join(',\n'));
		var code = '[' + (strplace.join(',\n\t')) + ']';
		prompt('copy and paste code', code);
	}

	function load() {
		// positions = [new THREE.Vector3(-213.12552068360054, -294.1922074745087, -0.03978996232257259), new THREE.Vector3(29.99553601021495, -243.11318001675306, 280.78482599069616), new THREE.Vector3(-97.75986506175894, -64.54552418022524, 55.64806371267258), new THREE.Vector3(-314.408250336442, 235.23205516762346, -5.893017170859991), new THREE.Vector3(22.034622881439077, 162.8965831284607, -345.10495452036184), new THREE.Vector3(134.59056654199452, 382.5168668673815, -198.91479606872133), new THREE.Vector3(477.5022172612489, -4.8651203633506555, -210.47236097401574), new THREE.Vector3(449.0486673017501, 4.918562856246474, 52.560123928679985), new THREE.Vector3(280.6397761972279, -290.27337790622795, 40.210017846524124), new THREE.Vector3(163.10498799765227, -369.03871116931487, -173.83095096616034)];

		positions = [new THREE.Vector3(289.76843686945404, 452.51481137238443, 56.10018915737797),
	new THREE.Vector3(-53.56300074753207, 171.49711742836848, -14.495472686253045),
	new THREE.Vector3(-91.40118730204415, 176.4306956436485, -6.958271935582161),
	new THREE.Vector3(-383.785318791128, 491.1365363371675, 47.869296953772746)];
		splinePointsLength = positions.length;
	}

	function animate() {
		requestAnimationFrame(animate);
		render();
		stats.update();
		// if (controls.enabled)
			controls.update();
		transformControl.update();
	}

	function render() {
		renderer.render(scene, camera);
	}

	</script>
</body>

</html>