<!doctype html>
<html lang="en">

<head>
	<title>three.js webgl - draggable 3d catmull spline editor</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		font-family: monospace;
		background-color: #f0f0f0;
		margin: 0px;
		overflow: hidden
	}

	</style>
</head>

<body>
	<script src="js/three.min.js"></script>
	<script src="js/stats.min.js"></script>
	<script src="js/Projector.js"></script>
	<script src="DragControls3.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/TransformControls.js"></script>
	<script src="js/CatmullRomCurve3.js"></script>

	<script>
	String.prototype.format = function () {
		var str = this;
		for (var i = 0; i < arguments.length; i++) {
			str = str.replace('{' + i + '}', arguments[i]);
		}
		return str;
	}

	var container, stats;
	var camera, scene, renderer;
	var splineHelperObjects = [],
		splineOutline;
	var splineCurve, splinePointsLength = 4;
	var positions = [];
	var options;
	
	var geometry = new THREE.BoxGeometry(20, 20, 20);
	

	var ARC_SEGMENTS = 200;
	var splineMesh;

	var splines = {

	};

	init();
	animate();

	function init() {
		container = document.createElement('div');
		document.body.appendChild(container);
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
		camera.position.z = 1000;
		scene.add(camera);

		scene.add(new THREE.AmbientLight(0xf0f0f0));
		var light = new THREE.SpotLight(0xffffff, 1.5);
		light.position.set(0, 1500, 200);
		light.castShadow = true;
		light.shadowCameraNear = 200;
		light.shadowCameraFar = camera.far;
		light.shadowCameraFov = 70;
		light.shadowBias = -0.000222;
		light.shadowDarkness = 0.25;
		light.shadowMapWidth = 1024;
		light.shadowMapHeight = 1024;
		scene.add(light);
		spotlight = light;
		var planeGeometry = new THREE.PlaneGeometry(2000, 2000, 20, 20);
		planeGeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
		var planeMaterials = [new THREE.MeshBasicMaterial({
			color: 0xeeeeee,
			opacity: 0.5
		}), new THREE.MeshBasicMaterial({
			color: 0x405040,
			wireframe: true,
			opacity: 0.2,
			transparent: true
		})];
		var plane = THREE.SceneUtils.createMultiMaterialObject(planeGeometry, planeMaterials);
		plane.position.y = -200;
		plane.children[0].castShadow = false;
		plane.children[0].receiveShadow = true;
		scene.add(plane);
		var axis = new THREE.AxisHelper();
		axis.position.set(-500, -500, -500);
		scene.add(axis);

		renderer = new THREE.WebGLRenderer({
			antialias: true
		});
		renderer.setClearColor( 0xf0f0f0 );
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		container.appendChild(renderer.domElement);
		var info = document.createElement('div');
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
		info.innerHTML = '<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> - simple 3d catmull-rom <a href="http://twitter.com/blurspline" target="_blank">@blurspline</a> spline editor';
		options = document.createElement('div');
		options.style.position = 'absolute';
		options.style.top = '30px';
		options.style.width = '100%';
		options.style.textAlign = 'center';

		options.innerHTML = 'Points: <input type="button" onclick="addPoint();" value="+" />\
		<input type="button" onclick="removePoint();" value="-" />\
		<input type="button" onclick="exportSpline();" value="Export" /><br />\
		<input type="checkbox" id="spline" /> SplineCurve<br />\
		<input type="checkbox" id="uniform" checked /> <label for="uniform">Uniform Catmull-rom</label>  <input type="range" id="tension" onchange="splines.uniform.tension = tension.value;updateSplineOutline();" min=0 max=1 step=0.01 value=0.5 /> <span id="tension_value" /></span> <br />\
		<input type="checkbox" id="centripetal" checked /> Centripetal Catmull-rom<br />\
		<input type="checkbox" id="chordal" checked /> Chordal Catmull-rom<br />';

		// options.innerHTML = '<div id="info2"></div>Points: \
		// 		<input type="button" onclick="points(1);" value="+" />\
		// 		<input type="button" onclick="points(-1);" value="-" /><br />\
		// 		<input type="button" onclick="addTube();" value="Create Tube" /><br />\
		// 		<input type="button" onclick="insertAfter();" value="Insert After" /><br />\
		// 		<input type="button" onclick="removeAction();" value="Delete" /><br />\
		// 		<input type="button" onclick="exportAction();" value="Export" />\
		// 		<input type="button" onclick="importAction();" value="Import" />\
		// 		<input type="button" onclick="exportToCode();" value="Export to Code" />';

		container.appendChild(info);
		container.appendChild(options);
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild(stats.domElement);

		// Controls
		controls = new THREE.OrbitControls( camera, renderer.domElement );
		controls.damping = 0.2;
		controls.addEventListener( 'change', render );

		transformControl = new THREE.TransformControls( camera, renderer.domElement );
		transformControl.addEventListener( 'change', render );
		// transformControl.setMode( "translate" );
		// transformControl.setSize( 100 );

		scene.add( transformControl );

		// Hiding transform situation is a little in a mess :()
		transformControl.addEventListener('change', function(e) {
			// console.log('change', e.target);
			cancelHideTransorm();
		});

		transformControl.addEventListener('mouseDown', function(e) {
			// controls.enabled = false;render
			cancelHideTransorm(); // *
		});

		transformControl.addEventListener('mouseUp', function(e) {
			// controls.enabled = true;
			// console.log('mouseUp', e, controls);
			delayHideTransform(); // *
		});

		transformControl.addEventListener('objectChange', function(e) {
			updateSplineOutline();
			// e.stopPropagation();

		});

		var dragcontrols = new THREE.DragControls(camera, splineHelperObjects, renderer.domElement); // 

		dragcontrols.on('hoveron', function(e) {
			transformControl.attach(e.object);
			cancelHideTransorm(); // *
		})

		dragcontrols.on('hoveroff', function(e) {
			if (e) delayHideTransform();
		})


		controls.addEventListener('start', function() {
			cancelHideTransorm();
		});

		// controls.addEventListener('change', function() {
		// 	delayHideTransform();
		// });


		controls.addEventListener('end', function() {
			delayHideTransform(); // *
		});



		var hiding;
		function delayHideTransform() {
			cancelHideTransorm();
			hideTransform();
		}

		function hideTransform() {
			hiding = setTimeout(function() {
				transformControl.detach(transformControl.object);
			}, 2500)
		}

		function cancelHideTransorm() {
			if (hiding) clearTimeout(hiding);
		}

		// dragcontrols.on('dragstart', function(e) {
		// 	controls.enabled = false;
		// });

		// dragcontrols.on('dragend', function() {
		// 	controls.enabled = true;
		// 	updateSplineOutline();
		// });


		/*******
		 * Curves
		 *********/

		var i;
		for (i = 0; i < splinePointsLength; i++) {
			addSplineObject(positions[i]);
		}
		positions = [];
		for (i = 0; i < splinePointsLength; i++) {
			positions.push(splineHelperObjects[i].position);
		}

		var geometry = new THREE.Geometry();

		for (var i = 0; i < ARC_SEGMENTS; i++) {
			geometry.vertices.push(new THREE.Vector3());
		}

		var curve = new THREE.SplineCurve3(positions)
		curve.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
			color: 0x000000,
			opacity: 0.35,
			linewidth: 2
		}));
		splines.spline = curve;

		curve = new THREE.CatmullRomCurve3(positions);
		curve.type = 'catmullrom';
		curve.mesh = new THREE.Line(geometry.clone(), new THREE.LineBasicMaterial({
			color: 0xff0000,
			opacity: 0.35,
			linewidth: 2
		}));
		splines.uniform = curve;

		curve = new THREE.CatmullRomCurve3(positions);
		curve.type = 'centripetal';
		curve.mesh = new THREE.Line(geometry.clone(), new THREE.LineBasicMaterial({
			color: 0x00ff00,
			opacity: 0.35,
			linewidth: 2
		}));
		splines.centripetal = curve;

		curve = new THREE.CatmullRomCurve3(positions);
		curve.type = 'chordal';
		curve.mesh = new THREE.Line(geometry.clone(), new THREE.LineBasicMaterial({
			color: 0x0000ff,
			opacity: 0.35,
			linewidth: 2
		}));
		splines.chordal = curve;

		for (var k in splines) {
			var spline = splines[k];
			scene.add(spline.mesh);
		}
		
		load();
		// updateSplineOutline();

	}

	function addSplineObject(position) {
		var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
			color: Math.random() * 0xffffff
		}));
		object.material.ambient = object.material.color;
		if (position) {
			object.position.copy(position);
		} else {
			object.position.x = Math.random() * 1000 - 500;
			object.position.y = Math.random() * 600
			object.position.z = Math.random() * 800 - 400;
		}
		object.castShadow = true;
		object.receiveShadow = true;
		scene.add(object);
		splineHelperObjects.push(object);
		return object;
	}

	function addPoint() {
		splinePointsLength ++;
		positions.push(addSplineObject()
					.position);

		updateSplineOutline();
	}

	function removePoint() {
		if (splinePointsLength <= 4) {
			return;
		}
		splinePointsLength --;
		positions.pop();
		scene.remove(splineHelperObjects.pop());
		
		updateSplineOutline();
	}

	function updateSplineOutline() {
		// if (splineOutline) scene.remove(splineOutline);
		// splineCurve.updateArcLengths();
		// var arcLen = splineCurve.getLength();
		// arcLen = Math.floor(arcLen / 20);
		// var spacedPoints = createLineGeometry(splineCurve.getPoints(arcLen));
		// splineOutline = new THREE.Line(spacedPoints, new THREE.LineBasicMaterial({
		// 	color: 0x000000,
		// 	opacity: 0.35
		// }));
		// scene.add(splineOutline);

		var p;

		for (var k in splines) {
			var spline = splines[k];

			splineMesh = spline.mesh;

			for (var i = 0; i < ARC_SEGMENTS; i++) {
				p = splineMesh.geometry.vertices[i];
				p.copy(spline.getPoint(i /  (ARC_SEGMENTS - 1)));
			}

			splineMesh.geometry.verticesNeedUpdate = true;
			
		}

		
	}

	function exportSpline() {
		var p;
		var strplace = [];
		for (i = 0; i < splinePointsLength; i++) {
			p = splineHelperObjects[i].position;
			strplace.push('new THREE.Vector3({0}, {1}, {2})'.format(p.x, p.y, p.z))
		}
		console.log(strplace.join(',\n'));
		var code = '[' + (strplace.join(',\n\t')) + ']';
		prompt('copy and paste code', code);
	}

	function load(new_positions) {
		new_positions = [new THREE.Vector3(-213.12552068360054, -294.1922074745087, -0.03978996232257259), new THREE.Vector3(29.99553601021495, -243.11318001675306, 280.78482599069616), new THREE.Vector3(-97.75986506175894, -64.54552418022524, 55.64806371267258), new THREE.Vector3(-314.408250336442, 235.23205516762346, -5.893017170859991), new THREE.Vector3(22.034622881439077, 162.8965831284607, -345.10495452036184), new THREE.Vector3(134.59056654199452, 382.5168668673815, -198.91479606872133), new THREE.Vector3(477.5022172612489, -4.8651203633506555, -210.47236097401574), new THREE.Vector3(449.0486673017501, 4.918562856246474, 52.560123928679985), new THREE.Vector3(280.6397761972279, -290.27337790622795, 40.210017846524124), new THREE.Vector3(163.10498799765227, -369.03871116931487, -173.83095096616034)];

		new_positions = [new THREE.Vector3(289.76843686945404, 452.51481137238443, 56.10018915737797),
	new THREE.Vector3(-53.56300074753207, 171.49711742836848, -14.495472686253045),
	new THREE.Vector3(-91.40118730204415, 176.4306956436485, -6.958271935582161),
	new THREE.Vector3(-383.785318791128, 491.1365363371675, 47.869296953772746)];

	// new_positions = [new THREE.Vector3(496.67234058451385, 713.7265572769854, 84.81943314428486),
	// new THREE.Vector3(10.966847239405658, 127.77487908510103, 109.91398030899873),
	// new THREE.Vector3(-35.32146057760889, 121.27819505763335, 100.66098380657866),
	// new THREE.Vector3(-503.45191292733756, 625.3271986161933, 95.45294615062474)]


		while (new_positions.length > positions.length) {
			addPoint();
		}

		while (new_positions.length < positions.length) {
			removePoint();
		}

		for (i=0; i < positions.length; i++) {
			positions[i].copy(new_positions[i]);
		}

		updateSplineOutline();

	}

	function animate() {
		requestAnimationFrame(animate);
		render();
		stats.update();
		// if (controls.enabled)
			controls.update();
		transformControl.update();
	}

	function render() {

		splines.spline.mesh.visible = spline.checked;
		splines.uniform.mesh.visible = uniform.checked;
		splines.centripetal.mesh.visible = centripetal.checked;
		splines.chordal.mesh.visible = chordal.checked;
		renderer.render(scene, camera);
	}

	</script>
</body>

</html>